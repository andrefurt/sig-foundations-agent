# rule: Foundations Component Composition
type: always
scope: **/*
---
**Goal**  
Apply **Significa Foundations** composition patterns consistently across components.

**Composition Guidance (source of truth)**  
---
applyTo: '**'
---

# Component Composition Principles

## Core Philosophy

Components should provide **behavior and extension points**, not configuration. We favor composition over props to keep components flexible, maintainable, and future-proof.

## When to Use Composition vs Props

### Use Props When ALL of These Are True:

1. The component has a single, stable responsibility
2. Variants are well-defined and enumerable (e.g., size, variant, disabled)
3. Internal structure won't need to change
4. The prop directly modifies intrinsic behavior

**Examples:**

```tsx
// ‚úÖ Good use of props
<Button variant="primary" size="lg" disabled={isLoading} />
<Avatar size="md" src={user.avatar} fallback={user.initials} />
<Badge variant="success">Active</Badge>
<Spinner size="sm" />
```

### Use Composition When ANY of These Are True:

1. Multiple child components might appear in various combinations
2. Layout/positioning of children matters to consumers
3. Children might need to communicate with the parent (via context)
4. You find yourself adding props like `showX`, `renderY`, `customZ`
5. Requirements include phrases like "sometimes", "optionally", "in some cases"
6. You're predicting what content/layout combinations users will need

**Examples:**

```tsx
// ‚úÖ Good use of composition
<Dialog>
  <Dialog.Trigger>Open</Dialog.Trigger>
  <Dialog.Content>
    <Dialog.Header>
      <Dialog.Title>Delete account</Dialog.Title>
      <Dialog.Description>This action cannot be undone.</Dialog.Description>
    </Dialog.Header>
    <Dialog.Footer>
      <Button variant="ghost">Cancel</Button>
      <Button variant="destructive">Delete</Button>
    </Dialog.Footer>
  </Dialog.Content>
</Dialog>
```

### Create a New Component When ANY of These Are True:

1. The use case has fundamentally different semantics
2. Trying to share code would require significant props/conditionals
3. The components serve different user intents
4. Domain terminology differs

**Examples:**

```tsx
// ‚úÖ Different components for different purposes
<AlertCard>...</AlertCard>      // Temporary user attention
<StatsCard>...</StatsCard>      // Permanent data display
<ProductCard>...</ProductCard>  // E-commerce specific

// ‚ùå Don't do this
<Card type="alert" | "stats" | "product">
```

## Red Flags: When to Refactor to Composition

### Prop-Level Warning Signs:

```tsx
// üö® Props that take objects with multiple properties
showAction?: {
  label: string
  onClick: () => void
  icon?: ReactNode
  variant?: string
}

// üö® Props that are mutually exclusive
showTrend?: boolean
showComparison?: boolean

// üö® Props that start with "render" or "custom"
renderFooter?: () => ReactNode
customHeader?: ReactNode

// üö® Props that control positioning/layout
iconPosition?: 'left' | 'right' | 'top'
actionPlacement?: 'header' | 'footer'

// üö® Props with names like "also", "additionally"
alsoShowBadge?: boolean
additionalContent?: ReactNode
```

### Component-Level Warning Signs:

```tsx
// üö® Excessive branching based on props
if (variant === 'compact') {
  if (showAction) {
    return <CompactWithAction />
  }
  return <Compact />
}

// üö® Mapping props to children
{
  showIcon && icon
}
{
  showBadge && badge
}

// üö® Comments like these
// TODO: This is getting messy
// HACK: Special case for mobile
// NOTE: Don't modify without checking all usage
```

### Architecture-Level Warning Signs:

- Component has >10 props (especially with >3 optional objects)
- Multiple people have "enhanced" the same component recently
- PRs touching the component require extensive review
- Component file is >300 lines
- Tests are hard to write or maintain
- Last 3 features required modifying this component
- Team members avoid touching it

## Building Composable Components

### Pattern 1: Basic Composition Structure

```tsx
// Root component - minimal props
interface CardProps {
  asChild?: boolean
  children: ReactNode
  className?: string
}

function CardRoot({ asChild, children, className }: CardProps) {
  const Comp = asChild ? Slot : 'div'
  return <Comp className={cn('card', className)}>{children}</Comp>
}

// Sub-components - semantic, single responsibility
function CardHeader({
  children,
  className,
}: {
  children: ReactNode
  className?: string
}) {
  return <div className={cn('card-header', className)}>{children}</div>
}

function CardTitle({
  children,
  className,
}: {
  children: ReactNode
  className?: string
}) {
  return <h3 className={cn('card-title', className)}>{children}</h3>
}

function CardContent({
  children,
  className,
}: {
  children: ReactNode
  className?: string
}) {
  return <div className={cn('card-content', className)}>{children}</div>
}

function CardFooter({
  children,
  className,
}: {
  children: ReactNode
  className?: string
}) {
  return <div className={cn('card-footer', className)}>{children}</div>
}

// Export with namespace
const Card = Object.assign(CardRoot, {
  Header: CardHeader,
  Title: CardTitle,
  Content: CardContent,
  Footer: CardFooter,
})

export { Card }
```

### Pattern 2: The `asChild` Pattern

Allow consumers to control the root element while preserving component behavior:

```tsx
import { Slot } from './slot' // Radix UI's Slot component

interface ButtonProps extends React.ComponentPropsWithRef<'button'> {
  asChild?: boolean
  variant?: 'primary' | 'secondary'
}

const Button = ({ asChild, variant, children, ...props }: ButtonProps) => {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      className={cn('button', variant && `button-${variant}`)}
      {...props}
    >
      {children}
    </Comp>
  )
}

// Usage - render as button (default)
<Button variant="primary">
  Submit
</Button>

// Usage - render as Link with button styling
<Button asChild variant="primary">
  <Link to="/profile">Go to Profile</Link>
</Button>

// Usage - render as custom element
<Button asChild>
  <motion.button
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
  >
    Animated Button
  </motion.button>
</Button>
```

**Key benefits:**

- Preserves component's styling and behavior
- Gives consumer full control over the underlying element
- No need for separate `ButtonLink`, `ButtonDiv`, etc. components
- Common in headless UI libraries (Radix, React Aria)

**When to use:**

- Component provides visual styling/behavior but shouldn't dictate the element
- Users need to render as links, form elements, or custom components
- Avoiding prop forwarding complexity (`href`, `to`, `onClick`, etc.)

**Implementation note:**
The `Slot` component merges props and refs from both the component and the child element, ensuring everything works seamlessly.

### Pattern 3: Context for Coordination

When sub-components need to adapt based on parent state, use context:

```tsx
interface MediaCardContextValue {
  format: 'square' | 'portrait' | 'landscape'
}

const MediaCardContext = createContext<MediaCardContextValue | null>(null)

function useMediaCardContext() {
  const context = use(MediaCardContext) // React 19: use() instead of useContext()
  if (!context) {
    throw new Error('MediaCard sub-components must be used within MediaCard')
  }
  return context
}

function MediaCardRoot({
  format,
  children,
}: {
  format: MediaCardContextValue['format']
  children: ReactNode
}) {
  const value = useMemo(() => ({ format }), [format])

  // React 19: No .Provider needed
  return (
    <MediaCardContext value={value}>
      <div className="media-card">{children}</div>
    </MediaCardContext>
  )
}

function MediaCardCover({ children }: { children: ReactNode }) {
  const { format } = useMediaCardContext()

  return (
    <div
      className={cn(
        'cover',
        format === 'portrait' && 'aspect-[3/4]',
        format === 'landscape' && 'aspect-[4/3]',
        format === 'square' && 'aspect-square'
      )}
    >
      {children}
    </div>
  )
}
```

**React 19 Context changes:**

- Use `use(Context)` instead of `useContext(Context)`
- Render `<Context value={...}>` directly, not `<Context.Provider value={...}>`
- Context is now a component, not an object with a Provider property

**Use context when:**

- Sub-components need to adapt based on parent state
- Avoids duplicating props on every child
- State is truly internal (not user-facing)

**Don't use context when:**

- Data should come from above (use regular props)
- Components can be used independently
- Only one child needs the data

### Pattern 4: Controlled Positioning

For components that need explicit positioning control:

```tsx
interface ControlProps {
  position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  children: ReactNode
}

function MediaCardControl({ position, children, onClick }: ControlProps) {
  return (
    <div
      className="absolute flex items-center gap-2"
      data-position={position}
      onClick={(e) => {
        e.stopPropagation() // Prevent bubbling to parent
        onClick?.(e)
      }}
    >
      {children}
    </div>
  )
}

// Usage
;<MediaCard>
  <MediaCard.Cover>
    <img src="cover.jpg" />
    <MediaCard.Control position="top-right">
      <IconButton>
        <XIcon />
      </IconButton>
    </MediaCard.Control>
    <MediaCard.Control position="bottom-left">
      <Badge>HD</Badge>
    </MediaCard.Control>
  </MediaCard.Cover>
</MediaCard>
```

## The Two-Layer Architecture

Build flexible primitives, then compose them into specific components for common patterns.

### Layer 1: Primitive Components (Composition-Based)

**Characteristics:**

- Generic, reusable patterns
- Design system components
- Will be used in many different ways
- Rarely change once stable
- Live in design system / component library

**Example:**

```tsx
// Flexible primitive
<Card>
  <Card.Image>...</Card.Image>
  <Card.Title>...</Card.Title>
  <Card.Content>...</Card.Content>
  <Card.Footer>...</Card.Footer>
</Card>
```

### Layer 2: Application Components (Props-Based)

**Characteristics:**

- Specific to your domain
- Repeated patterns in your app
- Single, clear use case
- Can change with business needs
- Compose primitives internally

**Example:**

```tsx
// App-specific, prop-based component
interface ProductCardProps {
  product: Product
  onAddToCart: (product: Product) => void
}

function ProductCard({ product, onAddToCart }: ProductCardProps) {
  return (
    <Card>
      <Card.Image>
        <img src={product.image} alt={product.name} />
        {product.discount && <Badge>-{product.discount}%</Badge>}
      </Card.Image>
      <Card.Title>{product.name}</Card.Title>
      <Card.Content>
        <span className="text-lg font-bold">${product.price}</span>
        {product.originalPrice && (
          <span className="text-muted line-through">
            ${product.originalPrice}
          </span>
        )}
      </Card.Content>
      <Card.Footer>
        <Button onClick={() => onAddToCart(product)}>Add to Cart</Button>
      </Card.Footer>
    </Card>
  )
}
```

**Build app-specific components when:**

- Same markup repeated 3+ times
- The pattern is specific to your domain
- You want to enforce consistency
- Reduces cognitive load for the team

**Don't build them when:**

- Only used once or twice
- Pattern varies significantly per use case
- Would need many props to handle variations

## Refactoring Strategy

### When to Refactor:

**Immediate (Next Sprint):**

- Component has >10 props with >3 being optional objects
- Last 3 features required modifying this component
- Multiple conditional render paths (>5 if statements)
- Team members avoid touching it

**Soon (Next Quarter):**

- Component has 6-10 props, adding more each month
- Tests are brittle, break on unrelated changes
- Multiple "special case" props (`showXWhenY`)

**Eventually (Opportunity-based):**

- Stable but messy implementation
- Works but isn't extensible
- Refactor when major feature requires it

### How to Refactor:

```tsx
// 1. Identify the primitives
// Keep as props: variant, size, disabled (intrinsic behavior)
// Move to children: icon, badge, complex content

// 2. Create composition API alongside old one
function Button({}: /* old props */ OldButtonProps) {
  /* ... */
}
function ButtonV2({ children }: { children: ReactNode }) {
  /* ... */
}

// 3. Use module augmentation for gradual migration
export const Button = ButtonV2
export const LegacyButton = OldButton

// 4. Deprecate with types
/** @deprecated Use composition pattern instead */
interface LegacyButtonProps {}

// 5. Add migration guide
/**
 * Migration:
 * Before: <Button icon="save" text="Save" />
 * After: <Button><SaveIcon />Save</Button>
 */
```

## Common Patterns

### Pattern: Button with Various Content

```tsx
// ‚ùå Don't do this
<Button icon="save" text="Save" badge="3" loading />

// ‚úÖ Do this
<Button isLoading={isLoading}>
  <SaveIcon />
  Save
  <Badge>3</Badge>
</Button>

// Handles all variations naturally:
<Button>
  <Avatar size="xs" src={user.avatar} />
  {user.name}
  {user.verified && <VerifiedIcon />}
  {messageCount > 0 && <Badge>{messageCount}</Badge>}
</Button>
```

### Pattern: Card with Flexible Layout

```tsx
// ‚ùå Don't do this
<StatsCard
  title="Revenue"
  value={45000}
  trend={{ value: 12, direction: 'up' }}
  comparison={{ label: 'vs last month', value: 38000 }}
/>

// ‚úÖ Do this
<StatsCard>
  <StatsCard.Title>Revenue</StatsCard.Title>
  <StatsCard.Value>$45,000</StatsCard.Value>
  <StatsCard.Meta className="flex gap-4">
    <Trend direction="up" value={12} />
    <span className="text-muted">vs $38,000 last month</span>
  </StatsCard.Meta>
</StatsCard>
```

### Pattern: Dialog with Custom Content

```tsx
// ‚ùå Don't do this
<Dialog
  title="Delete account"
  description="This cannot be undone"
  actions={[
    { label: 'Cancel', onClick: handleCancel },
    { label: 'Delete', onClick: handleDelete, variant: 'destructive' }
  ]}
/>

// ‚úÖ Do this
<Dialog>
  <Dialog.Trigger>Delete account</Dialog.Trigger>
  <Dialog.Content>
    <Dialog.Header>
      <Dialog.Title>Delete account</Dialog.Title>
      <Dialog.Description>This cannot be undone</Dialog.Description>
    </Dialog.Header>
    <Dialog.Footer>
      <Button variant="ghost" onClick={handleCancel}>Cancel</Button>
      <Button variant="destructive" onClick={handleDelete}>Delete</Button>
    </Dialog.Footer>
  </Dialog.Content>
</Dialog>
```

## Testing Composable Components

### Test Each Sub-Component Independently

```tsx
describe('Card', () => {
  it('renders root with children', () => {
    render(<Card>Content</Card>)
    expect(screen.getByText('Content')).toBeInTheDocument()
  })

  it('applies className to root', () => {
    render(<Card className="custom">Content</Card>)
    expect(screen.getByText('Content').parentElement).toHaveClass('custom')
  })
})

describe('Card.Header', () => {
  it('renders header with children', () => {
    render(<Card.Header>Header</Card.Header>)
    expect(screen.getByText('Header')).toBeInTheDocument()
  })
})
```

### Test Composition Patterns

```tsx
describe('Card composition', () => {
  it('allows flexible composition', () => {
    render(
      <Card>
        <Card.Header>
          <Card.Title>Title</Card.Title>
        </Card.Header>
        <Card.Content>Content</Card.Content>
        <Card.Footer>Footer</Card.Footer>
      </Card>
    )

    expect(screen.getByText('Title')).toBeInTheDocument()
    expect(screen.getByText('Content')).toBeInTheDocument()
    expect(screen.getByText('Footer')).toBeInTheDocument()
  })
})
```

## Key Principles Summary

1. **Provide behavior, not layout** - Let consumers control structure
2. **Offer extension points, not configuration** - Composition over props
3. **Trust the consumer** - They know their use case best
4. **Each component does ONE thing** - Single responsibility
5. **Props for intrinsic behavior** - Size, variant, disabled, etc.
6. **Children for content structure** - Layout, combinations, customization
7. **Context bridges coordination needs** - Share state without prop drilling
8. **Build app-specific wrappers** - Abstract repeated patterns
9. **Every prop is a promise** - Maintain forever, choose wisely
10. **Prevent the first broken window** - Push back on layout/structure props

## Questions to Ask

Before adding a prop, ask:

1. Does this control WHERE something appears? (Layout decision ‚Üí composition)
2. Am I limiting how consumers structure content? (‚Üí composition)
3. Would different designs need different values? (‚Üí composition)
4. Is this really the component's responsibility? (‚Üí might be parent's job)
5. Could this be achieved by rendering children? (‚Üí composition)

If the answer to any is "yes", consider composition instead.  

**Slots & Separation**
- Expose **named slots** (e.g., `leading`, `trailing`, `media`, `actions`, `meta`) when suitable.
- Keep **visual wrappers** (presentational) separate from **hooks/data** (behavior).
- Reuse **Foundations primitives** instead of re-inventing widgets.

**Variants**
- Implement `variant`, `size`, and boolean flags via typed variant helpers.
- Keep class composition centralized (e.g., `cn()` utilities).

**API Design**
- Public surface must be minimal and **stable**; mark experiments clearly.
- Avoid leaking implementation details (Radix primitives, DOM structure) unless explicitly part of the contract.